import numpy as np
import glob
import sys
from collections import defaultdict

def extract_data_from_files(strategy="cmek-cmek-hsm-csek-keywrap-strawman-akeso", num_files=10):
    """
    Extract data from multiple .dat files generated by automate.sh
    
    Args:
        strategy: The strategy name used in the filename pattern
        num_files: Number of files to read (default 10)
    
    Returns:
        Dictionary with structure: {size: {method: [values]}}
    """
    data = defaultdict(lambda: defaultdict(list))
    
    # Pattern to match the files
    file_pattern = f"update-{strategy}-*.dat"
    files = glob.glob(file_pattern)
    
    # Sort files by number to ensure consistent ordering
    files_with_nums = []
    for f in files:
        try:
            # Extract number from filename
            num = int(f.split('-')[-1].replace('.dat', ''))
            files_with_nums.append((num, f))
        except ValueError:
            print(f"Warning: Could not extract number from filename {f}")
    
    files_with_nums.sort()
    files = [f[1] for f in files_with_nums[:num_files]]
    
    if not files:
        print(f"No files found matching pattern: {file_pattern}")
        return None
    
    print(f"Found {len(files)} files to process:")
    for f in files:
        print(f"  - {f}")
    print()  # Blank line for readability
    
    # Read each file and extract data
    for filepath in files:
        try:
            with open(filepath, 'r') as f:
                lines = f.readlines()
                
                # Skip header line
                if len(lines) < 2:
                    print(f"Warning: File {filepath} has insufficient data")
                    continue
                
                # Parse header to get method names
                header = lines[0].strip()
                if header.startswith('#'):
                    methods = header.split('\t')[1:]  # Skip '#ObjectSizes'
                else:
                    print(f"Warning: Invalid header in {filepath}")
                    continue
                
                # Parse data lines
                for line in lines[1:]:
                    parts = line.strip().split('\t')
                    if len(parts) != len(methods) + 1:
                        continue
                    
                    size = parts[0]
                    for i, method in enumerate(methods):
                        try:
                            value = float(parts[i + 1])
                            data[size][method].append(value)
                        except (ValueError, IndexError):
                            print(f"Warning: Could not parse value for {size}/{method} in {filepath}")
                            
        except IOError as e:
            print(f"Error reading file {filepath}: {e}")
    
    return data

def calculate_normalized_statistics(data, output_file='combined.dat', cmek_means_file='cmek_means.gpi'):
    """
    Calculate means and standard errors normalized by CMEK mean
    
    Args:
        data: Dictionary with structure {size: {method: [values]}}
        output_file: Name of output file
        cmek_means_file: Name of file to save CMEK means for gnuplot
    """
    if not data:
        print("No data to process")
        return
    
    # Get all methods from the data
    first_size = next(iter(data))
    methods_in_data = list(data[first_size].keys())
    
    # Use the specific method order
    methods = ['cmek', 'cmek-hsm', 'csek', 'keywrap', 'strawman', 'akeso']
    
    # Filter to only include methods that exist in the data
    methods = [m for m in methods if m in methods_in_data]
    
    # Add any additional methods not in the predefined list
    for m in methods_in_data:
        if m not in methods:
            methods.append(m)
    
    # Define size order - adjust based on what sizes are in your data
    # This mapping helps convert between different size formats
    size_mapping = {
        '16MB': '16MB',
        '128MB': '128MB', 
        '512MB': '512MB',
        '1GB': '1GB',
        '10GB': '10GB',
        # Add mappings for other possible size formats
        '1024MB': '1GB',
        '10240MB': '10GB'
    }
    
    # Get sizes from data and sort them
    sizes_in_data = list(data.keys())
    
    # Try to sort sizes logically
    def size_to_bytes(size_str):
        """Convert size string to bytes for sorting"""
        size_str = size_str.upper()
        if 'KB' in size_str:
            return float(size_str.replace('KB', '')) * 1024
        elif 'MB' in size_str:
            return float(size_str.replace('MB', '')) * 1024 * 1024
        elif 'GB' in size_str:
            return float(size_str.replace('GB', '')) * 1024 * 1024 * 1024
        else:
            return 0
    
    sizes_sorted = sorted(sizes_in_data, key=size_to_bytes)
    
    # Dictionary to store CMEK means for gnuplot
    cmek_means = {}
    
    with open(output_file, 'w') as f:
        # Write header
        header_parts = ["#BucketSize"]
        for method in methods:
            header_parts.extend([method, f"{method}_err"])
        f.write("\t".join(header_parts) + "\n")
        
        # Process each size
        for size in sizes_sorted:
            # Check if we need to use cmek for normalization
            if 'cmek' not in data[size]:
                print(f"Warning: No CMEK data for size {size}, skipping normalization for this size")
                continue
                
            # Calculate CMEK mean first (needed for normalization)
            cmek_values = np.array(data[size]['cmek'])
            if len(cmek_values) == 0:
                print(f"Warning: Empty CMEK data for size {size}, skipping")
                continue
                
            cmek_mean = np.mean(cmek_values)
            
            # Store CMEK mean for this size
            cmek_means[size] = cmek_mean
            
            # Use mapped size name if available, otherwise use original
            display_size = size_mapping.get(size, size)
            row = [display_size]
            
            for method in methods:
                if method not in data[size]:
                    # If method missing, add placeholder values
                    row.extend(["0.0000", "0.0000"])
                    print(f"Warning: No data for {method} at size {size}")
                    continue
                    
                values = np.array(data[size][method])
                
                if len(values) == 0:
                    row.extend(["0.0000", "0.0000"])
                    continue
                
                mean = np.mean(values)
                std = np.std(values, ddof=1) if len(values) > 1 else 0
                stderr = std / np.sqrt(len(values))
                
                # Print statistics (matching original format with "STD")
                print("%s %s Mean: %.3f STD: %.3f" % (method, size, mean, std))
                
                # Normalize by CMEK mean
                normalized_mean = mean / cmek_mean
                normalized_stderr = stderr / cmek_mean
                
                row.extend([f"{normalized_mean:.4f}", f"{normalized_stderr:.4f}"])
            
            f.write("\t".join(row) + "\n")
    
    # Write CMEK means to a gnuplot-readable file
    with open(cmek_means_file, 'w') as f:
        f.write("# CMEK mean values for gnuplot\n")
        
        # Create variable names compatible with gnuplot
        for size, mean_val in cmek_means.items():
            # Convert size to gnuplot-friendly variable name
            var_name = f"cmek_{size.replace('GB', 'GB').replace('MB', 'M')}_mean"
            f.write(f"{var_name} = {mean_val:.3f}\n")
    
    print(f"\nResults written to {output_file}")
    print(f"CMEK means written to {cmek_means_file}")
    print("Note: All values normalized by CMEK mean for each size")

def main():
    # Default values
    strategy = "cmek-cmek-hsm-csek-keywrap-strawman-akeso"
    num_files = 10
    output_file = "combined.dat"
    cmek_means_file = "cmek_means.gpi"
    
    # Parse command line arguments
    if len(sys.argv) > 1:
        strategy = sys.argv[1]
    if len(sys.argv) > 2:
        num_files = int(sys.argv[2])
    if len(sys.argv) > 3:
        output_file = sys.argv[3]
    if len(sys.argv) > 4:
        cmek_means_file = sys.argv[4]
    
    print(f"Processing files with strategy: {strategy}")
    print(f"Looking for {num_files} files")
    print(f"Output will be written to: {output_file}")
    print(f"CMEK means will be written to: {cmek_means_file}")
    print("-" * 50)
    
    # Extract data from files
    data = extract_data_from_files(strategy, num_files)
    
    if data:
        # Calculate normalized statistics and write output
        print("\nCalculating normalized statistics:")
        print("-" * 50)
        calculate_normalized_statistics(data, output_file, cmek_means_file)
    else:
        print("No data extracted. Please check your files.")

if __name__ == "__main__":
    main()