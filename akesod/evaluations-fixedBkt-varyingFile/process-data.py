import numpy as np
import glob
import sys
from collections import defaultdict

def extract_data_from_files(strategy="cmek-cmek-hsm-csek-keywrap-strawman-akeso", num_files=10):
    """
    Extract data from multiple .dat files generated by automate.sh
    
    Args:
        strategy: The strategy name used in the filename pattern
        num_files: Number of files to read (default 10)
    
    Returns:
        Dictionary with structure: {size: {method: [values]}}
    """
    data = defaultdict(lambda: defaultdict(list))
    
    # Pattern to match the files
    file_pattern = f"update-{strategy}-*.dat"
    files = glob.glob(file_pattern)
    
    # Sort files by number to ensure consistent ordering
    files_with_nums = []
    for f in files:
        try:
            # Extract number from filename
            num = int(f.split('-')[-1].replace('.dat', ''))
            files_with_nums.append((num, f))
        except ValueError:
            print(f"Warning: Could not extract number from filename {f}")
    
    files_with_nums.sort()
    files = [f[1] for f in files_with_nums[:num_files]]
    
    if not files:
        print(f"No files found matching pattern: {file_pattern}")
        return None
    
    print(f"Found {len(files)} files to process:")
    for f in files:
        print(f"  - {f}")
    print()  # Blank line for readability
    
    # Read each file and extract data
    for filepath in files:
        try:
            with open(filepath, 'r') as f:
                lines = f.readlines()
                
                # Skip header line
                if len(lines) < 2:
                    print(f"Warning: File {filepath} has insufficient data")
                    continue
                
                # Parse header to get method names
                header = lines[0].strip()
                if header.startswith('#'):
                    methods = header.split('\t')[1:]  # Skip '#ObjectSizes'
                else:
                    print(f"Warning: Invalid header in {filepath}")
                    continue
                
                # Parse data lines
                for line in lines[1:]:
                    parts = line.strip().split('\t')
                    if len(parts) != len(methods) + 1:
                        continue
                    
                    size = parts[0]
                    for i, method in enumerate(methods):
                        try:
                            value = float(parts[i + 1])
                            data[size][method].append(value)
                        except (ValueError, IndexError):
                            print(f"Warning: Could not parse value for {size}/{method} in {filepath}")
                            
        except IOError as e:
            print(f"Error reading file {filepath}: {e}")
    
    return data

def calculate_statistics_and_write(data, output_file='combined.dat'):
    """
    Calculate means and standard errors, then write to output file
    
    Args:
        data: Dictionary with structure {size: {method: [values]}}
        output_file: Name of output file
    """
    if not data:
        print("No data to process")
        return
    
    # Get all methods from the data (assuming all sizes have same methods)
    first_size = next(iter(data))
    methods_in_data = list(data[first_size].keys())
    
    # Use the specific method order from the original script
    methods = ['cmek', 'cmek-hsm', 'csek', 'keywrap', 'strawman', 'akeso']
    
    # Filter to only include methods that exist in the data
    methods = [m for m in methods if m in methods_in_data]
    
    # Add any additional methods not in the predefined list
    for m in methods_in_data:
        if m not in methods:
            methods.append(m)
    
    size_order_preferred = ['1MB', '2MB', '4MB', '16MB']
    size_order = []
    
    # First add sizes in preferred order if they exist
    for size in size_order_preferred:
        if size in data:
            size_order.append(size)
    
    # Then add any remaining sizes
    for size in data.keys():
        if size not in size_order:
            size_order.append(size)
    
    with open(output_file, 'w') as f:
        # Write header
        header_parts = ["#Size"]
        for method in methods:
            header_parts.extend([method, f"{method}_min", f"{method}_max"])
        f.write("\t".join(header_parts) + "\n")
        
        # Process each size
        for size in size_order:
            row = [size]
            
            for method in methods:
                if method not in data[size]:
                    # If method missing, add placeholder values
                    row.extend(["0.000", "0.000", "0.000"])
                    print(f"Warning: No data for {method} at size {size}")
                    continue
                    
                values = np.array(data[size][method])
                
                if len(values) == 0:
                    row.extend(["0.000", "0.000", "0.000"])
                    continue
                
                mean = np.mean(values)
                std = np.std(values, ddof=1) if len(values) > 1 else 0
                stderr = std / np.sqrt(len(values))
                
                # Print statistics in the same format as the original script
                print("%s %s Mean: %.3f Std: %.3f" % (method, size, mean, std))
                
                # For error bars, using stderr for smaller error bars
                row.extend([f"{mean:.3f}", f"{mean-stderr:.3f}", f"{mean+stderr:.3f}"])
            
            f.write("\t".join(row) + "\n")
    
    print(f"\nResults written to {output_file}")

def main():
    # Default values
    strategy = "cmek-cmek-hsm-csek-keywrap-strawman-akeso"
    num_files = 10
    output_file = "combined.dat"
    
    # Parse command line arguments
    if len(sys.argv) > 1:
        strategy = sys.argv[1]
    if len(sys.argv) > 2:
        num_files = int(sys.argv[2])
    if len(sys.argv) > 3:
        output_file = sys.argv[3]
    
    print(f"Processing files with strategy: {strategy}")
    print(f"Looking for {num_files} files")
    print(f"Output will be written to: {output_file}")
    print("-" * 50)
    
    # Extract data from files
    data = extract_data_from_files(strategy, num_files)
    
    if data:
        # Calculate statistics and write output
        print("\nCalculating statistics:")
        print("-" * 50)
        calculate_statistics_and_write(data, output_file)
    else:
        print("No data extracted. Please check your files.")

if __name__ == "__main__":
    main()